Day-1 - Docker
-------------------------------------------------

https://www.virtualbox.org/wiki/Downloads


https://www.osboxes.org/virtualbox-images/#google_vignette


----------------------------------------------------------------------
apt install docker.io -y

docker --version




Docker version 28.2.2, build 28.2.2-0ubuntu1~24.04.1

docker pull 

docker run -it -d -p 8080:8080 jenkins/jenkins:lts

docker
run -- 
-it -- 
-d means 
-p 8080:8080

jenkins/jenkins:lts

run -- can Pull and run

-----------------------------------------------------------------------------------------------
Docker Session Summary - Day 1 (February 3, 2026)
Key Topics Covered:
Introduction to Docker and Microservices

Discussed the problems with traditional virtual machines (VMs): heavy size, difficult transportation between environments, and high resource requirements
Explained microservices architecture and its benefits: independent services, easier scaling, and reduced failure impact
Introduced Docker as a solution for packaging applications with dependencies into lightweight, portable images
Virtualization vs. Containerization

Covered VM architecture: Hardware â†’ Host OS â†’ Hypervisor â†’ Guest OS â†’ Application
Highlighted VM disadvantages: heavy hardware requirements, large size (2-10GB+), difficult migration
Explained Docker's advantage: reduced OS size to approximately 72MB for Ubuntu
Core Docker Concepts

Image: Packaged binary, libraries, and dependencies with operating system in one box
Container: Running instance of an image
Node: VM with application installed
Docker: Platform to build, ship, and run applications anywhere
Practical Implementation

Installed Docker on Ubuntu machine using Google Cloud Platform
Demonstrated automation with command-line VM creation
Pulled Jenkins LTS image from Docker Hub (size: 491MB vs traditional 5-10GB)
Successfully ran Jenkins container with port mapping (8080:8080)
Learned commands: docker images, docker ps, docker run -d -p
Key Takeaways

Docker solves dependency and portability issues
Platform-independent deployment
Significantly reduced application size
Faster provisioning and deployment

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

Docker Q&A Practice Questions
1. What problem does Docker solve compared to traditional VMs?

VMs are heavy (2-10GB+), difficult to transport between environments, and require significant hardware resources. Docker reduces OS size to ~72MB and makes applications portable with all dependencies packaged together.
2. What is the difference between a Docker image and a container?

Image: A packaged binary with libraries, dependencies, and OS in one box
Container: A running instance of that image
3. Explain the architecture difference between VMs and Docker.

VM: Hardware â†’ Host OS â†’ Hypervisor â†’ Guest OS â†’ Application
Docker: Hardware â†’ Host OS â†’ Docker Engine â†’ Container (shared OS kernel)
4. What are the benefits of microservices architecture?

Independent services that can be developed and deployed separately
Easier to scale specific components
Reduced impact when one service fails
Better resource utilization
5. What command did we use to run Jenkins container?

docker run -d -p 8080:8080 jenkins/jenkins:lts
-d: detached mode, -p: port mapping
6. What is the typical size comparison?

Traditional Jenkins VM: 5-10GB
Jenkins Docker image: 491MB
Ubuntu Docker base: ~72MB
----------------------------------------------------------------------------------------------------


Docker Practical Session - Hands-On Activities
1. Environment Setup

Created Ubuntu VM on Google Cloud Platform
Installed Docker on the Ubuntu machine
Verified Docker installation
2. Pulled Jenkins Image from Docker Hub

Command: docker pull jenkins/jenkins:lts
Downloaded Jenkins LTS (Long Term Support) version
Image size: 491MB (much smaller than traditional 5-10GB VM)
3. Viewed Docker Images

Command: docker images
Verified Jenkins image was successfully downloaded
Checked image details (repository, tag, size)
4. Ran Jenkins Container

Command: docker run -d -p 8080:8080 jenkins/jenkins:lts
-d: Run container in detached mode (background)
-p 8080:8080: Map host port 8080 to container port 8080
Successfully started Jenkins service
5. Verified Running Container

Command: docker ps
Checked container status and details
Confirmed Jenkins was running and accessible
6. Accessed Jenkins

Opened Jenkins web interface on port 8080
Demonstrated successful deployment of application using Docker

----------------------------------------------------------------------------------------------------
LinkedIn Post - Docker Learning Journey
ðŸš€ Day 1: Diving into Docker & Containerization!

Just completed an intensive Docker session and I'm excited to share what I learned:

Key Highlights:

Explored how Docker solves the challenges of traditional VMs - reducing application size from 5-10GB to just 491MB!
Understood the shift from monolithic to microservices architecture
Learned the difference between Docker images and containers
Got hands-on experience deploying Jenkins using Docker in minutes
Practical Achievement:
Successfully pulled and ran Jenkins container on Google Cloud Platform with just a few commands. What used to take hours of setup is now done in minutes!

Main Takeaway:
Docker isn't just a tool - it's a game-changer for application deployment, making it faster, lighter, and truly platform-independent.

Excited to continue this learning journey and explore more containerization concepts!

#Docker #DevOps #Containerization #CloudComputing #LearningJourney #Jenkins #Microservices #TechSkills



59bc435e1f03

docker exec -it 950bc4014507 /bin/bash

docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword